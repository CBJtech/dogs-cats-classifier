# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GjQ2_O2yuVkYcb3Md13uv_QTSTfwK3oL
"""

!pip install gdown
import gdown
import os
import torch

# Path where the model will be saved
model_path = "model.pt"

# Download only if it doesn't exist
if not os.path.exists(model_path):
    url = "https://drive.google.com/file/d/1ySr9Xf7p9xoE58ebl0wN-6p2Zu0y09G2/"
    gdown.download(url, model_path, quiet=False)

# Load your model
model = MyModelClass(*args)  # define your model
model.load_state_dict(torch.load(model_path))
model.eval()


# Commented out IPython magic to ensure Python compatibility.
# ========================================
# FILE 1: app.py (Main Streamlit App)
# ========================================
# %pip install streamlit
import streamlit as st
import torch
import torch.nn as nn
import torch.nn.functional as F
import cv2
import numpy as np
from PIL import Image
import gdown
import os

# Model Definition
class Net(nn.Module):
    def __init__(self):
        super().__init__()
        self.conv1 = nn.Conv2d(1, 32, 5)
        self.conv2 = nn.Conv2d(32, 64, 5)
        self.conv3 = nn.Conv2d(64, 128, 5)
        self.fc1 = nn.Linear(128*12*12, 512)
        self.fc2 = nn.Linear(512, 2)

    def convs(self, x):
        x = F.max_pool2d(F.relu(self.conv1(x)), (2, 2))
        x = F.max_pool2d(F.relu(self.conv2(x)), (2, 2))
        x = F.max_pool2d(F.relu(self.conv3(x)), (2, 2))
        return x

    def forward(self, x):
        x = self.convs(x)
        x = x.view(-1, 128*12*12)
        x = F.relu(self.fc1(x))
        x = self.fc2(x)
        return x

@st.cache_resource
def load_model():
    """Load the trained model"""
    device = torch.device("cpu")  # Streamlit Cloud uses CPU
    model = Net().to(device)

    # Download model from Google Drive or load from file
    model_path = "model.pth"

    if not os.path.exists(model_path):
        # If you upload model to Google Drive, uncomment and add your file ID:
        # file_id = "YOUR_GOOGLE_DRIVE_FILE_ID"
        # gdown.download(f"https://drive.google.com/uc?id={file_id}", model_path, quiet=False)
        st.error("Model file not found! Please upload your trained model.")
        st.stop()

    try:
        model.load_state_dict(torch.load(model_path, map_location=device))
        model.eval()
        return model, device
    except Exception as e:
        st.error(f"Error loading model: {str(e)}")
        st.stop()

def predict_image(model, uploaded_file, device):
    """Predict uploaded image"""
    try:
        image = Image.open(uploaded_file)

        # Convert to grayscale if needed
        if image.mode != 'L':
            image = image.convert('L')

        # Convert PIL to numpy array
        img_array = np.array(image)

        # Apply same preprocessing as training
        img_resized = cv2.resize(img_array, (128, 128))
        img_tensor = torch.from_numpy(img_resized).float().unsqueeze(0).unsqueeze(0)
        img_tensor = img_tensor / 255.0
        img_tensor = (img_tensor - 0.5) / 0.5
        img_tensor = img_tensor.to(device)

        # Make prediction
        with torch.no_grad():
            outputs = model(img_tensor)
            probabilities = F.softmax(outputs, dim=1)
            predicted_class = torch.argmax(outputs, dim=1).item()
            confidence = probabilities[0][predicted_class].item()

        return {
            'image': img_array,
            'prediction': 'Cat' if predicted_class == 0 else 'Dog',
            'confidence': confidence,
            'probabilities': {
                'Cat': probabilities[0][0].item(),
                'Dog': probabilities[0][1].item()
            }
        }
    except Exception as e:
        st.error(f"Error processing image: {str(e)}")
        return None

def main():
    st.set_page_config(
        page_title="ğŸ±ğŸ¶ Dogs vs Cats Classifier",
        page_icon="ğŸ±",
        layout="wide",
        initial_sidebar_state="expanded"
    )

    st.title("ğŸ±ğŸ¶ Dogs vs Cats Classifier")
    st.markdown("Upload an image of a cat or dog and let our AI model classify it!")

    # Sidebar with model info
    with st.sidebar:
        st.header("ğŸ“Š Model Information")
        st.write("**Architecture:** Custom CNN")
        st.write("**Input Size:** 128x128 grayscale")
        st.write("**Classes:** Cat (ğŸ±), Dog (ğŸ¶)")
        st.write("**Framework:** PyTorch")

        st.markdown("---")
        st.header("ğŸ” How it works")
        st.write("1. Upload a clear image")
        st.write("2. Image is resized to 128x128")
        st.write("3. CNN processes the image")
        st.write("4. Get prediction + confidence")

        st.markdown("---")
        st.write("**Tips for best results:**")
        st.write("â€¢ Use clear, well-lit images")
        st.write("â€¢ Make sure animal is main subject")
        st.write("â€¢ Avoid heavily filtered images")

    # Load model
    try:
        model, device = load_model()
    except:
        st.error("Failed to load model. Please check if model.pth exists.")
        return

    # Main interface
    col1, col2 = st.columns([1, 1])

    with col1:
        st.header("ğŸ“ Upload Image")
        uploaded_file = st.file_uploader(
            "Choose an image...",
            type=['jpg', 'jpeg', 'png', 'bmp'],
            help="Upload a clear image of a cat or dog"
        )

        if uploaded_file is not None:
            image = Image.open(uploaded_file)
            st.image(image, caption="Uploaded Image", use_column_width=True)

    with col2:
        st.header("ğŸ¯ Prediction Results")

        if uploaded_file is not None:
            if st.button("ğŸ” Classify Image", type="primary", use_container_width=True):
                with st.spinner("ğŸ¤– Analyzing image..."):
                    result = predict_image(model, uploaded_file, device)

                if result is not None:
                    prediction = result['prediction']
                    confidence = result['confidence']

                    # Confidence styling
                    if confidence > 0.8:
                        confidence_color = "ğŸŸ¢"
                        confidence_text = "High Confidence"
                    elif confidence > 0.6:
                        confidence_color = "ğŸŸ¡"
                        confidence_text = "Medium Confidence"
                    else:
                        confidence_color = "ğŸ”´"
                        confidence_text = "Low Confidence"

                    # Main prediction
                    st.success(f"**Prediction: {prediction}** {'ğŸ±' if prediction == 'Cat' else 'ğŸ¶'}")
                    st.markdown(f"### {confidence_color} Confidence: {confidence:.1%}")
                    st.caption(confidence_text)

                    # Progress bars
                    st.subheader("ğŸ“Š Class Probabilities")

                    cat_prob = result['probabilities']['Cat']
                    dog_prob = result['probabilities']['Dog']

                    col_a, col_b = st.columns(2)

                    with col_a:
                        st.write("ğŸ± **Cat**")
                        st.progress(cat_prob)
                        st.write(f"{cat_prob:.1%}")

                    with col_b:
                        st.write("ğŸ¶ **Dog**")
                        st.progress(dog_prob)
                        st.write(f"{dog_prob:.1%}")

                    # Additional metrics
                    st.subheader("ğŸ“ˆ Detailed Metrics")

                    col_c, col_d = st.columns(2)
                    with col_c:
                        st.metric("Predicted Class", prediction)
                        st.metric("Cat Score", f"{cat_prob:.3f}")
                    with col_d:
                        st.metric("Confidence", f"{confidence:.1%}")
                        st.metric("Dog Score", f"{dog_prob:.3f}")

        else:
            st.info("ğŸ‘† Please upload an image to get started!")
            st.markdown("### ğŸ¯ Try these sample images:")
            st.write("Upload any cat or dog image to test the classifier!")

    # Footer
    st.markdown("---")
    st.markdown(
        """
        <div style='text-align: center'>
            <p>Built with â¤ï¸ using PyTorch and Streamlit</p>
            <p>ğŸš€ Deployed on Streamlit Community Cloud</p>
        </div>
        """,
        unsafe_allow_html=True
    )

if __name__ == "__main__":
    main()

